{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/blackstoneteam/repos/viralizing-web/app/packages/mizzao:timesync/timesync-client.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining","pipelineOperator","throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"sourceFileName":"packages/mizzao:timesync/timesync-client.js","filename":"/home/blackstoneteam/repos/viralizing-web/app/packages/mizzao:timesync/timesync-client.js","passPerPreset":false,"envName":"development","cwd":"/home/blackstoneteam/repos/viralizing-web/app","root":"/home/blackstoneteam/repos/viralizing-web/app","presets":[],"generatorOpts":{"filename":"/home/blackstoneteam/repos/viralizing-web/app/packages/mizzao:timesync/timesync-client.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/mizzao:timesync/timesync-client.js"}},"code":"//IE8 doesn't have Date.now()\nDate.now = Date.now || function () {\n  return +new Date();\n};\n\nTimeSync = {\n  loggingEnabled: true\n};\n\nfunction log()\n/* arguments */\n{\n  if (TimeSync.loggingEnabled) {\n    Meteor._debug.apply(this, arguments);\n  }\n}\n\nvar defaultInterval = 1000; // Internal values, exported for testing\n\nSyncInternals = {\n  offset: undefined,\n  roundTripTime: undefined,\n  offsetDep: new Deps.Dependency(),\n  syncDep: new Deps.Dependency(),\n  isSynced: false,\n  timeTick: {},\n  getDiscrepancy: function (lastTime, currentTime, interval) {\n    return currentTime - (lastTime + interval);\n  }\n};\nSyncInternals.timeTick[defaultInterval] = new Deps.Dependency();\nvar maxAttempts = 5;\nvar attempts = 0;\n/*\n  This is an approximation of\n  http://en.wikipedia.org/wiki/Network_Time_Protocol\n\n  If this turns out to be more accurate under the connect handlers,\n  we should try taking multiple measurements.\n */\n\nvar syncUrl;\n\nif (Meteor.isCordova) {\n  // Only use Meteor.absoluteUrl for Cordova; see\n  // https://github.com/meteor/meteor/issues/4696\n  // https://github.com/mizzao/meteor-timesync/issues/30\n  // Cordova should never be running out of a subdirectory...\n  syncUrl = Meteor.absoluteUrl(\"_timesync\");\n} else {\n  // Support Meteor running in relative paths, based on computed root url prefix\n  // https://github.com/mizzao/meteor-timesync/pull/40\n  const basePath = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX || '';\n  syncUrl = basePath + \"/_timesync\";\n}\n\nvar updateOffset = function () {\n  var t0 = Date.now();\n  HTTP.get(syncUrl, function (err, response) {\n    var t3 = Date.now(); // Grab this now\n\n    if (err) {\n      //  We'll still use our last computed offset if is defined\n      log(\"Error syncing to server time: \", err);\n      if (++attempts <= maxAttempts) Meteor.setTimeout(TimeSync.resync, 1000);else log(\"Max number of time sync attempts reached. Giving up.\");\n      return;\n    }\n\n    attempts = 0; // It worked\n\n    var ts = parseInt(response.content);\n    SyncInternals.isSynced = true;\n    SyncInternals.offset = Math.round((ts - t0 + (ts - t3)) / 2);\n    SyncInternals.roundTripTime = t3 - t0; // - (ts - ts) which is 0\n\n    SyncInternals.offsetDep.changed();\n  });\n}; // Reactive variable for server time that updates every second.\n\n\nTimeSync.serverTime = function (clientTime, interval) {\n  check(interval, Match.Optional(Match.Integer)); // If a client time is provided, we don't need to depend on the tick.\n\n  if (!clientTime) getTickDependency(interval || defaultInterval).depend();\n  SyncInternals.offsetDep.depend(); // depend on offset to enable reactivity\n  // Convert Date argument to epoch as necessary\n\n  return (+clientTime || Date.now()) + SyncInternals.offset;\n}; // Reactive variable for the difference between server and client time.\n\n\nTimeSync.serverOffset = function () {\n  SyncInternals.offsetDep.depend();\n  return SyncInternals.offset;\n};\n\nTimeSync.roundTripTime = function () {\n  SyncInternals.offsetDep.depend();\n  return SyncInternals.roundTripTime;\n};\n\nTimeSync.isSynced = function () {\n  SyncInternals.offsetDep.depend();\n  return SyncInternals.isSynced;\n};\n\nvar resyncIntervalId = null;\n\nTimeSync.resync = function () {\n  if (resyncIntervalId !== null) Meteor.clearInterval(resyncIntervalId);\n  updateOffset();\n  resyncIntervalId = Meteor.setInterval(updateOffset, 600000);\n}; // Run this as soon as we load, even before Meteor.startup()\n// Run again whenever we reconnect after losing connection\n\n\nvar wasConnected = false;\nDeps.autorun(function () {\n  var connected = Meteor.status().connected;\n  if (connected && !wasConnected) TimeSync.resync();\n  wasConnected = connected;\n}); // Resync if unexpected change by more than a few seconds. This needs to be\n// somewhat lenient, or a CPU-intensive operation can trigger a re-sync even\n// when the offset is still accurate. In any case, we're not going to be able to\n// catch very small system-initiated NTP adjustments with this, anyway.\n\nvar tickCheckTolerance = 5000;\nvar lastClientTime = Date.now(); // Set up a new interval for any amount of reactivity.\n\nfunction getTickDependency(interval) {\n  if (!SyncInternals.timeTick[interval]) {\n    var dep = new Deps.Dependency();\n    Meteor.setInterval(function () {\n      dep.changed();\n    }, interval);\n    SyncInternals.timeTick[interval] = dep;\n  }\n\n  return SyncInternals.timeTick[interval];\n} // Set up special interval for the default tick, which also watches for re-sync\n\n\nMeteor.setInterval(function () {\n  var currentClientTime = Date.now();\n  var discrepancy = SyncInternals.getDiscrepancy(lastClientTime, currentClientTime, defaultInterval);\n\n  if (Math.abs(discrepancy) < tickCheckTolerance) {\n    // No problem here, just keep ticking along\n    SyncInternals.timeTick[defaultInterval].changed();\n  } else {\n    // resync on major client clock changes\n    // based on http://stackoverflow.com/a/3367542/1656818\n    log(\"Clock discrepancy detected. Attempting re-sync.\"); // Refuse to compute server time and try to guess new server offset. Guessing only works if the server time hasn't changed.\n\n    SyncInternals.offset = SyncInternals.offset - discrepancy;\n    SyncInternals.isSynced = false;\n    SyncInternals.offsetDep.changed();\n    TimeSync.resync();\n  }\n\n  lastClientTime = currentClientTime;\n}, defaultInterval);","map":{"version":3,"sources":["packages/mizzao:timesync/timesync-client.js"],"names":["Date","now","TimeSync","loggingEnabled","log","Meteor","_debug","apply","arguments","defaultInterval","SyncInternals","offset","undefined","roundTripTime","offsetDep","Deps","Dependency","syncDep","isSynced","timeTick","getDiscrepancy","lastTime","currentTime","interval","maxAttempts","attempts","syncUrl","isCordova","absoluteUrl","basePath","__meteor_runtime_config__","ROOT_URL_PATH_PREFIX","updateOffset","t0","HTTP","get","err","response","t3","setTimeout","resync","ts","parseInt","content","Math","round","changed","serverTime","clientTime","check","Match","Optional","Integer","getTickDependency","depend","serverOffset","resyncIntervalId","clearInterval","setInterval","wasConnected","autorun","connected","status","tickCheckTolerance","lastClientTime","dep","currentClientTime","discrepancy","abs"],"mappings":"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","sourcesContent":["//IE8 doesn't have Date.now()\nDate.now = Date.now || function() { return +new Date; };\n\nTimeSync = {\n  loggingEnabled: true\n};\n\nfunction log(/* arguments */) {\n  if (TimeSync.loggingEnabled) {\n    Meteor._debug.apply(this, arguments);\n  }\n}\n\nvar defaultInterval = 1000;\n\n// Internal values, exported for testing\nSyncInternals = {\n  offset: undefined,\n  roundTripTime: undefined,\n  offsetDep: new Deps.Dependency(),\n  syncDep: new Deps.Dependency(),\n  isSynced: false,\n  timeTick: {},\n  getDiscrepancy: function (lastTime, currentTime, interval) {\n    return currentTime - (lastTime + interval)\n  }\n};\n\nSyncInternals.timeTick[defaultInterval] = new Deps.Dependency();\n\nvar maxAttempts = 5;\nvar attempts = 0;\n\n/*\n  This is an approximation of\n  http://en.wikipedia.org/wiki/Network_Time_Protocol\n\n  If this turns out to be more accurate under the connect handlers,\n  we should try taking multiple measurements.\n */\n\nvar syncUrl;\nif (Meteor.isCordova) {\n  // Only use Meteor.absoluteUrl for Cordova; see\n  // https://github.com/meteor/meteor/issues/4696\n  // https://github.com/mizzao/meteor-timesync/issues/30\n  // Cordova should never be running out of a subdirectory...\n  syncUrl = Meteor.absoluteUrl(\"_timesync\");\n}\nelse {\n  // Support Meteor running in relative paths, based on computed root url prefix\n  // https://github.com/mizzao/meteor-timesync/pull/40\n  const basePath = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX || '';\n  syncUrl = basePath + \"/_timesync\";\n}\n\nvar updateOffset = function() {\n  var t0 = Date.now();\n\n  HTTP.get(syncUrl, function(err, response) {\n    var t3 = Date.now(); // Grab this now\n    if (err) {\n      //  We'll still use our last computed offset if is defined\n      log(\"Error syncing to server time: \", err);\n      if (++attempts <= maxAttempts)\n        Meteor.setTimeout(TimeSync.resync, 1000);\n      else\n        log(\"Max number of time sync attempts reached. Giving up.\");\n      return;\n    }\n\n    attempts = 0; // It worked\n\n    var ts = parseInt(response.content);\n    SyncInternals.isSynced = true;\n    SyncInternals.offset = Math.round(((ts - t0) + (ts - t3)) / 2);\n    SyncInternals.roundTripTime = t3 - t0; // - (ts - ts) which is 0\n    SyncInternals.offsetDep.changed();\n  });\n};\n\n// Reactive variable for server time that updates every second.\nTimeSync.serverTime = function(clientTime, interval) {\n  check(interval, Match.Optional(Match.Integer));\n  // If a client time is provided, we don't need to depend on the tick.\n  if ( !clientTime ) getTickDependency(interval || defaultInterval).depend();\n\n  SyncInternals.offsetDep.depend(); // depend on offset to enable reactivity\n  // Convert Date argument to epoch as necessary\n  return (+clientTime || Date.now()) + SyncInternals.offset;\n};\n\n// Reactive variable for the difference between server and client time.\nTimeSync.serverOffset = function() {\n  SyncInternals.offsetDep.depend();\n  return SyncInternals.offset;\n};\n\nTimeSync.roundTripTime = function() {\n  SyncInternals.offsetDep.depend();\n  return SyncInternals.roundTripTime;\n};\n\nTimeSync.isSynced = function() {\n  SyncInternals.offsetDep.depend();\n  return SyncInternals.isSynced;\n};\n\nvar resyncIntervalId = null;\n\nTimeSync.resync = function() {\n  if (resyncIntervalId !== null) Meteor.clearInterval(resyncIntervalId);\n  updateOffset();\n  resyncIntervalId = Meteor.setInterval(updateOffset, 600000);\n};\n\n// Run this as soon as we load, even before Meteor.startup()\n// Run again whenever we reconnect after losing connection\nvar wasConnected = false;\n\nDeps.autorun(function() {\n  var connected = Meteor.status().connected;\n  if ( connected && !wasConnected ) TimeSync.resync();\n  wasConnected = connected;\n});\n\n// Resync if unexpected change by more than a few seconds. This needs to be\n// somewhat lenient, or a CPU-intensive operation can trigger a re-sync even\n// when the offset is still accurate. In any case, we're not going to be able to\n// catch very small system-initiated NTP adjustments with this, anyway.\nvar tickCheckTolerance = 5000;\n\nvar lastClientTime = Date.now();\n\n// Set up a new interval for any amount of reactivity.\nfunction getTickDependency(interval) {\n\n  if ( !SyncInternals.timeTick[interval] ) {\n    var dep  = new Deps.Dependency();\n\n    Meteor.setInterval(function() {\n      dep.changed();\n    }, interval);\n\n    SyncInternals.timeTick[interval] = dep;\n  }\n\n  return SyncInternals.timeTick[interval];\n}\n\n// Set up special interval for the default tick, which also watches for re-sync\nMeteor.setInterval(function() {\n  var currentClientTime = Date.now();\n\n  var discrepancy = SyncInternals.getDiscrepancy(lastClientTime, currentClientTime, defaultInterval);\n  if (Math.abs(discrepancy) < tickCheckTolerance) {\n    // No problem here, just keep ticking along\n    SyncInternals.timeTick[defaultInterval].changed();\n  } else {\n    // resync on major client clock changes\n    // based on http://stackoverflow.com/a/3367542/1656818\n    log(\"Clock discrepancy detected. Attempting re-sync.\");\n    // Refuse to compute server time and try to guess new server offset. Guessing only works if the server time hasn't changed.\n    SyncInternals.offset = SyncInternals.offset - discrepancy;\n    SyncInternals.isSynced = false;\n    SyncInternals.offsetDep.changed();\n    TimeSync.resync();\n  }\n\n  lastClientTime = currentClientTime;\n}, defaultInterval);\n"]},"sourceType":"script","hash":"73b20a2247b0fa02b0974d91162e61c8a49441a3"}
